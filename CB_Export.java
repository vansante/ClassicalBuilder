/**
 * Copyright © 2006-2008 Paul van Santen & Erik Kerkvliet,
 *
 * This file is part of ClassicalBuilder.
 *
 * ClassicalBuilder is free software); you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * ClassicalBuilder is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with ClassicalBuilder; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * http://www.gnu.org/licenses/gpl.txt
**/

package ClassicalBuilder;

import java.util.Calendar;

public class CB_Export {

	private final CB_Instance instance;
	private final StringBuilder output = new StringBuilder();

	private static final String NEW_LINE = "\n";

	public CB_Export(CB_Instance instance, boolean full) {
		this.instance = instance;
		if (full) {
			this.generateHeader();
			this.generateColors();
			this.generateBox();
			this.generateParticles();
			this.generateInteractions();
			this.generateConstraints();
			this.generateConformation();
			this.generateTemperature();
			this.generateTrajectory();
			this.generateFooter();
		}
	}
	public String getOutput() {
		return output.toString();
	}
	public void generateHeader() {
		output.append("####################################################################" + NEW_LINE);
		output.append("#" + NEW_LINE);
		output.append("#  ClassicalDynamics input file" + NEW_LINE);
		output.append("#" + NEW_LINE);
		output.append("#  Generated by " + CB_Main.TITLE + " " + CB_Main.VERSION + NEW_LINE);
		output.append("#  On '" + Calendar.getInstance().getTime().toString() + "' (" + Calendar.getInstance().getTimeInMillis() + ")" + NEW_LINE);
		output.append("#" + NEW_LINE);
		output.append("#  " + CB_Main.CLASSICALBUILDER_WEBSITE + NEW_LINE);
		output.append("#" + NEW_LINE);
		output.append("####################################################################" + NEW_LINE + NEW_LINE);
	}
	public void generateColors() {
		output.append("# Colors:" + NEW_LINE);
		for (int i = 0; i < instance.getColors().size(); i++) {
			output.append("	color id=" + i + " rgb=[" + instance.getColor(i).getRed() + "," + instance.getColor(i).getGreen() + "," + instance.getColor(i).getBlue() + "]");
			output.append(" #!CB name=\"" + instance.getColor(i).getName().replace('"', ' ') + "\"");
			output.append(NEW_LINE);
		}
		output.append(NEW_LINE);
	}
	public void generateBox() {
		output.append("# Box:" + NEW_LINE);
		output.append("	box ");
		if (instance.getBox().getType() == CB_Box.TYPE_CELL) {
			output.append("cell");
		} else if (instance.getBox().getType() == CB_Box.TYPE_PERIODIC) {
			output.append("periodic");
		}
		output.append("=[" + instance.getBox().getDimension(CB_Box.WIDTH) + "," + instance.getBox().getDimension(CB_Box.HEIGHT) + "," + instance.getBox().getDimension(CB_Box.DEPTH) + "]");
		output.append(NEW_LINE + NEW_LINE);
	}
	public void generateParticles() {
		output.append("# Particles:" + NEW_LINE);
		for (int i = 0; i < instance.getParticles().size(); i++) {
			output.append("	particle id=" + i + " c=" + instance.getParticle(i).getColor());
			output.append(" m=" + instance.getParticle(i).getMass() + " q=" + instance.getParticle(i).getCharge());
			output.append(" r=" + instance.getParticle(i).getRadius());
			output.append(" x=[" + instance.getParticle(i).getPosIndex(CB_Particle.X) + "," + instance.getParticle(i).getPosIndex(CB_Particle.Y) + "," + instance.getParticle(i).getPosIndex(CB_Particle.Z) + "]");
			output.append(" p=[" + instance.getParticle(i).getMomIndex(CB_Particle.X) + "," + instance.getParticle(i).getMomIndex(CB_Particle.Y) + "," + instance.getParticle(i).getMomIndex(CB_Particle.Z) + "]");
			output.append(" #!CB name=\"" + instance.getParticle(i).getName().replace('"', ' ') + "\"");
			output.append(NEW_LINE);
		}
		output.append(NEW_LINE);
	}
	public void generateInteractions() {
		output.append("# Interactions:" + NEW_LINE);
		for (int u = 0; u < instance.getInteractions().size(); u++) {
			switch (instance.getInteraction(u).getType()) {
				case CB_Interaction.GRAVITATIONAL:
					output.append("	interaction gravity f=" + instance.getInteraction(u).getForce());
				break;
				case CB_Interaction.COULOMB:
					output.append("	interaction coulomb f=" + instance.getInteraction(u).getForce());
				break;
				case CB_Interaction.LENNARD_JONES:
					output.append("	interaction lennardjones f=" + instance.getInteraction(u).getForce());
					output.append(" r0=" + instance.getInteraction(u).getEquilibrium());
				break;
				case CB_Interaction.MORSE:
					output.append("	interaction morse f=" + instance.getInteraction(u).getForce());
					output.append(" r0=" + instance.getInteraction(u).getEquilibrium());
					output.append(" exp=" + instance.getInteraction(u).getExponential());
				break;
				case CB_Interaction.RYDBERG:
					output.append("	interaction rydberg f=" + instance.getInteraction(u).getForce());
					output.append(" r0=" + instance.getInteraction(u).getEquilibrium());
					output.append(" exp=" + instance.getInteraction(u).getExponential());
					output.append(" a1=" + instance.getInteraction(u).getA1());
					output.append(" a2=" + instance.getInteraction(u).getA2());
					output.append(" a3=" + instance.getInteraction(u).getA3());
				break;
				case CB_Interaction.HARMONIC_STRETCH:
					output.append("	interaction harmonic f=" + instance.getInteraction(u).getForce());
					output.append(" r0=" + instance.getInteraction(u).getEquilibrium());
				break;
				case CB_Interaction.HARMONIC_BENDING:
					output.append("	interaction bending f=" + instance.getInteraction(u).getForce());
					output.append(" deg=" + instance.getInteraction(u).getDegree());
				break;
				case CB_Interaction.PERIODIC_TORSIONAL:
					output.append("	interaction torsional n=" + instance.getInteraction(u).getPeriod());
					output.append(" f=" + instance.getInteraction(u).getForce());
					output.append(" deg=" + instance.getInteraction(u).getDegree());
				break;
			}
			output.append(" { " + instance.getInteraction(u).getParticlesString() + " } #!CB name=\"" + instance.getInteraction(u).getName().replace('"', ' ') + "\"");
			output.append(NEW_LINE);
		}
		output.append(NEW_LINE);
	}
	public void generateConstraints() {
		output.append("# Constraints:" + NEW_LINE);
		for (int u = 0; u < instance.getConstraints().size(); u++) {
			switch (instance.getConstraint(u).getType()) {
				case CB_Constraint.DISTANCE:
					output.append("	constrain distance");
					if (instance.getConstraint(u).isDistanceEnabled()) {
					 	output.append(" r=" + instance.getConstraint(u).getDistance());
					}
					if (instance.getConstraint(u).isMaxstepEnabled()) {
						output.append(" maxstep=" + instance.getConstraint(u).getMaxstep());
					}
					if (instance.getConstraint(u).isErrorEnabled()) {
						output.append(" error=" + instance.getConstraint(u).getError());
					}
				break;
			}
			output.append("{ " + instance.getConstraint(u).getParticlesString() + " }" + " #!CB name=\"" + instance.getConstraint(u).getName().replace('"', ' ') + "\"");
			output.append(NEW_LINE);
		}
		output.append(NEW_LINE);
	}
	public void generateConformation() {
		if (instance.getBox().isConfEnabled()) {
			output.append("# Conformation:" + NEW_LINE);
			output.append("	conformation n=" + instance.getBox().getConfNSteps() + " error=" + instance.getBox().getConfError());
			if (instance.getBox().isConfMaxstepEnabled()) {
				output.append(" maxstep=" + instance.getBox().getConfMaxstep());
			}
			output.append(NEW_LINE + NEW_LINE);
		}
	}
	public void generateTemperature() {
		if (instance.getBox().isTempEnabled()) {
			output.append("# Temperature:" + NEW_LINE);
			output.append("	temperature k=" + instance.getBox().getTempBoltzmann());
			if (instance.getBox().getTempType() == CB_Box.TEMP_TYPE_CONSTANT) {
				output.append(" constant=" + instance.getBox().getTempTemperature());
				if (instance.getBox().isTempTauEnabled()) {
					output.append(" tau=" + instance.getBox().getTempTau());
				}
				if (instance.getBox().isTempAdvancedEnabled()) {
					if (instance.getBox().getTempAdvancedType() == CB_Box.TEMP_ADV_TYPE_GAMMA) {
						output.append(" gamma=" + instance.getBox().getTempGamma());
					} else if (instance.getBox().getTempAdvancedType() == CB_Box.TEMP_ADV_TYPE_RMF) {
						output.append(" rmf=" + instance.getBox().getTempRmf());
					}
					if (instance.getBox().isTempCmrfEnabled()) {
						output.append(" cmrf=" + instance.getBox().getTempCmrf());
					}
				}
			} else {
				output.append(" initial=" + instance.getBox().getTempTemperature());
			}
			output.append(NEW_LINE + NEW_LINE);
		}
	}
	public void generateTrajectory() {
		if (instance.getBox().isTrajEnabled()) {
			output.append("# Dynamics:" + NEW_LINE);
			output.append("	dynamics dt=" + instance.getBox().getTrajTimestep());
			if (instance.getBox().getTrajType() == CB_Box.TRAJ_TYPE_END) {
				output.append(" tend=" + instance.getBox().getTrajEnd() + " ");
				output.append(" t=" + instance.getBox().getTrajStart());
			} else if (instance.getBox().getTrajType() == CB_Box.TRAJ_TYPE_N) {
				output.append(" t=" + instance.getBox().getTrajStart());
				output.append(" n=" + instance.getBox().getTrajNSteps());
			}
			if (instance.getBox().isTrajErrorEnabled() && instance.getBox().getTrajError() != 0) {
				output.append(" error=" + instance.getBox().getTrajError());
			}
			if (instance.getBox().isTrajSnapshotsEnabled()) {
				output.append(" snapshots=" + instance.getBox().getTrajSnapshots());
			}
			output.append(NEW_LINE + NEW_LINE);
		}
	}
	public void generateFooter() {
		output.append("# End input file" + NEW_LINE);
	}
}
